/**
 * Groth16 Proof Verification using Solana's alt_bn128 syscalls
 * 
 * This module provides zero-knowledge proof verification on-chain
 * using the BN254 (alt_bn128) elliptic curve operations via syscalls.
 */

use anchor_lang::prelude::*;

/// Groth16 verification key (hardcoded for the census circuit)
/// In production, this would be loaded from an account or PDA
pub struct VerificationKey {
    pub alpha: [u8; 64],
    pub beta: [u8; 128],
    pub gamma: [u8; 128],
    pub delta: [u8; 128],
    pub ic: Vec<[u8; 64]>, // IC points (one per public input + 1)
}

/// Verify a Groth16 proof using Solana's alt_bn128 syscalls
/// 
/// This implements the pairing check:
/// e(A, B) = e(alpha, beta) * e(C, delta) * e(IC, gamma)
/// 
/// Where IC = IC[0] + sum(public_inputs[i] * IC[i+1])
pub fn verify_groth16_proof(
    proof_a: &[u8; 64],
    proof_b: &[u8; 128],
    proof_c: &[u8; 64],
    public_inputs: &[[u8; 32]],
    vkey: &VerificationKey,
) -> Result<bool> {
    // Validate proof components are valid curve points
    require!(
        is_valid_g1_point(proof_a),
        ErrorCode::InvalidProofPoint
    );
    require!(
        is_valid_g2_point(proof_b),
        ErrorCode::InvalidProofPoint
    );
    require!(
        is_valid_g1_point(proof_c),
        ErrorCode::InvalidProofPoint
    );

    // Compute linear combination of IC points with public inputs
    // IC_computed = IC[0] + sum(public_inputs[i] * IC[i+1])
    let ic_combined = compute_ic_combination(public_inputs, &vkey.ic)?;

    // Perform pairing check using Solana's alt_bn128 operations
    // e(proof_a, proof_b) == e(alpha, beta) * e(ic_combined, gamma) * e(proof_c, delta)
    let pairing_result = perform_pairing_check(
        proof_a,
        proof_b,
        &vkey.alpha,
        &vkey.beta,
        &ic_combined,
        &vkey.gamma,
        proof_c,
        &vkey.delta,
    )?;

    Ok(pairing_result)
}

/// Validate that a point is on the BN254 G1 curve
fn is_valid_g1_point(point: &[u8; 64]) -> bool {
    // Extract x and y coordinates (32 bytes each)
    let x = &point[0..32];
    let y = &point[32..64];

    // Check if point is (0, 0) - point at infinity is valid
    if is_zero(x) && is_zero(y) {
        return true;
    }

    // Verify the point satisfies the curve equation: y^2 = x^3 + 3
    // This is a simplified check - full validation uses alt_bn128_addition with identity
    let addition_input = [point.as_slice(), &[0u8; 64]].concat();
    
    // Try to add the point to itself (doubling)
    // If this fails, the point is not on the curve
    match syscall_alt_bn128_addition(&addition_input) {
        Ok(_) => true,
        Err(_) => false,
    }
}

/// Validate that a point is on the BN254 G2 curve
fn is_valid_g2_point(point: &[u8; 128]) -> bool {
    // G2 points are 128 bytes (4 field elements)
    // Similar validation as G1 but with different curve parameters
    // For simplicity, we check for zero point or rely on pairing to fail
    !is_zero(&point[0..32]) || !is_zero(&point[32..64]) || 
    !is_zero(&point[64..96]) || !is_zero(&point[96..128])
}

/// Compute linear combination: IC[0] + sum(public_inputs[i] * IC[i+1])
fn compute_ic_combination(
    public_inputs: &[[u8; 32]],
    ic_points: &[[u8; 64]],
) -> Result<[u8; 64]> {
    require!(
        public_inputs.len() + 1 == ic_points.len(),
        ErrorCode::InvalidPublicInputCount
    );

    // Start with IC[0]
    let mut result = ic_points[0];

    // Add each scaled IC point
    for (i, input) in public_inputs.iter().enumerate() {
        // Scalar multiply: IC[i+1] * public_inputs[i]
        let scaled_point = scalar_mul_g1(&ic_points[i + 1], input)?;
        
        // Add to accumulator
        result = add_g1_points(&result, &scaled_point)?;
    }

    Ok(result)
}

/// Perform the pairing check for Groth16 verification
/// e(A, B) == e(alpha, beta) * e(IC, gamma) * e(C, delta)
/// 
/// Solana's pairing check format:
/// e(P1[0], P2[0]) * e(P1[1], P2[1]) * ... == 1
fn perform_pairing_check(
    proof_a: &[u8; 64],
    proof_b: &[u8; 128],
    alpha: &[u8; 64],
    beta: &[u8; 128],
    ic_combined: &[u8; 64],
    gamma: &[u8; 128],
    proof_c: &[u8; 64],
    delta: &[u8; 128],
) -> Result<bool> {
    // Negate proof_a (required by Solana's pairing implementation)
    let negated_proof_a = negate_g1_point(proof_a);

    // Build pairing input: concatenate all pairs
    // Format: [G1_point1, G2_point1, G1_point2, G2_point2, ...]
    let mut pairing_input = Vec::with_capacity(64 + 128 + 64 + 128 + 64 + 128 + 64 + 128);
    
    // e(-A, B)
    pairing_input.extend_from_slice(&negated_proof_a);
    pairing_input.extend_from_slice(proof_b);
    
    // e(alpha, beta)
    pairing_input.extend_from_slice(alpha);
    pairing_input.extend_from_slice(beta);
    
    // e(IC, gamma)
    pairing_input.extend_from_slice(ic_combined);
    pairing_input.extend_from_slice(gamma);
    
    // e(C, delta)
    pairing_input.extend_from_slice(proof_c);
    pairing_input.extend_from_slice(delta);

    // Perform pairing check
    match syscall_alt_bn128_pairing(&pairing_input) {
        Ok(result) => {
            // Result should be 1 (multiplicative identity in GT)
            Ok(result[0] == 1)
        }
        Err(_) => Ok(false),
    }
}

/// Scalar multiplication on G1: point * scalar
fn scalar_mul_g1(point: &[u8; 64], scalar: &[u8; 32]) -> Result<[u8; 64]> {
    let mut input = Vec::with_capacity(96);
    input.extend_from_slice(point);
    input.extend_from_slice(scalar);

    syscall_alt_bn128_multiplication(&input)
        .map(|result| {
            let mut output = [0u8; 64];
            output.copy_from_slice(&result[0..64]);
            output
        })
        .map_err(|_| ErrorCode::ScalarMultiplicationFailed.into())
}

/// Add two G1 points
fn add_g1_points(p1: &[u8; 64], p2: &[u8; 64]) -> Result<[u8; 64]> {
    let mut input = Vec::with_capacity(128);
    input.extend_from_slice(p1);
    input.extend_from_slice(p2);

    syscall_alt_bn128_addition(&input)
        .map(|result| {
            let mut output = [0u8; 64];
            output.copy_from_slice(&result[0..64]);
            output
        })
        .map_err(|_| ErrorCode::PointAdditionFailed.into())
}

/// Negate a G1 point by negating the y-coordinate
/// y_neg = FIELD_PRIME - y (mod FIELD_PRIME)
fn negate_g1_point(point: &[u8; 64]) -> [u8; 64] {
    let mut negated = [0u8; 64];
    negated[0..32].copy_from_slice(&point[0..32]); // x stays the same

    // For BN254, FIELD_PRIME = 21888242871839275222246405745257275088696311157297823662689037894645226208583
    // y_neg = FIELD_PRIME - y
    let field_prime: [u8; 32] = [
        0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29,
        0xb8, 0x50, 0x45, 0xb6, 0x81, 0x81, 0x58, 0x5d,
        0x97, 0x81, 0x6a, 0x91, 0x68, 0x71, 0xca, 0x8d,
        0x3c, 0x20, 0x8c, 0x16, 0xd8, 0x7c, 0xfd, 0x47,
    ];

    // Subtract y from FIELD_PRIME
    let y = &point[32..64];
    let mut borrow = 0u16;
    
    for i in (0..32).rev() {
        let diff = field_prime[i] as u16 - y[i] as u16 - borrow;
        negated[32 + i] = (diff & 0xFF) as u8;
        borrow = if diff < 0x100 { 0 } else { 1 };
    }

    negated
}

/// Check if a byte slice is all zeros
fn is_zero(bytes: &[u8]) -> bool {
    bytes.iter().all(|&b| b == 0)
}

/// Get verification key for the census circuit
/// Auto-generated from: snarkjs zkey export verificationkey
/// Generated: 2025-11-28T18:20:36.885Z
/// Circuit: census.circom
pub fn get_verification_key() -> VerificationKey {
    VerificationKey {
        alpha: [
            // x coordinate
            0x2d, 0x4d, 0x9a, 0xa7, 0xe3, 0x02, 0xd9, 0xdf, 0x41, 0x74, 0x9d, 0x55, 0x07, 0x94, 0x9d, 0x05,
            0xdb, 0xea, 0x33, 0xfb, 0xb1, 0x6c, 0x64, 0x3b, 0x22, 0xf5, 0x99, 0xa2, 0xbe, 0x6d, 0xf2, 0xe2,
            // y coordinate
            0x14, 0xbe, 0xdd, 0x50, 0x3c, 0x37, 0xce, 0xb0, 0x61, 0xd8, 0xec, 0x60, 0x20, 0x9f, 0xe3, 0x45,
            0xce, 0x89, 0x83, 0x0a, 0x19, 0x23, 0x03, 0x01, 0xf0, 0x76, 0xca, 0xff, 0x00, 0x4d, 0x19, 0x26,
        ],
        
        beta: [
            // x.c0
            0x0e, 0x18, 0x78, 0x47, 0xad, 0x4c, 0x79, 0x83, 0x74, 0xd0, 0xd6, 0x73, 0x2b, 0xf5, 0x01, 0x84,
            0x7d, 0xd6, 0x8b, 0xc0, 0xe0, 0x71, 0x24, 0x1e, 0x02, 0x13, 0xbc, 0x7f, 0xc1, 0x3d, 0xb7, 0xab,
            // x.c1
            0x09, 0x67, 0x03, 0x2f, 0xcb, 0xf7, 0x76, 0xd1, 0xaf, 0xc9, 0x85, 0xf8, 0x88, 0x77, 0xf1, 0x82,
            0xd3, 0x84, 0x80, 0xa6, 0x53, 0xf2, 0xde, 0xca, 0xa9, 0x79, 0x4c, 0xbc, 0x3b, 0xf3, 0x06, 0x0c,
            // y.c0
            0x17, 0x39, 0xc1, 0xb1, 0xa4, 0x57, 0xa8, 0xc7, 0x31, 0x31, 0x23, 0xd2, 0x4d, 0x2f, 0x91, 0x92,
            0xf8, 0x96, 0xb7, 0xc6, 0x3e, 0xea, 0x05, 0xa9, 0xd5, 0x7f, 0x06, 0x54, 0x7a, 0xd0, 0xce, 0xc8,
            // y.c1
            0x30, 0x4c, 0xfb, 0xd1, 0xe0, 0x8a, 0x70, 0x4a, 0x99, 0xf5, 0xe8, 0x47, 0xd9, 0x3f, 0x8c, 0x3c,
            0xaa, 0xfd, 0xde, 0xc4, 0x6b, 0x7a, 0x0d, 0x37, 0x9d, 0xa6, 0x9a, 0x4d, 0x11, 0x23, 0x46, 0xa7,
        ],
        
        gamma: [
            // x.c0
            0x18, 0x00, 0xde, 0xef, 0x12, 0x1f, 0x1e, 0x76, 0x42, 0x6a, 0x00, 0x66, 0x5e, 0x5c, 0x44, 0x79,
            0x67, 0x43, 0x22, 0xd4, 0xf7, 0x5e, 0xda, 0xdd, 0x46, 0xde, 0xbd, 0x5c, 0xd9, 0x92, 0xf6, 0xed,
            // x.c1
            0x19, 0x8e, 0x93, 0x93, 0x92, 0x0d, 0x48, 0x3a, 0x72, 0x60, 0xbf, 0xb7, 0x31, 0xfb, 0x5d, 0x25,
            0xf1, 0xaa, 0x49, 0x33, 0x35, 0xa9, 0xe7, 0x12, 0x97, 0xe4, 0x85, 0xb7, 0xae, 0xf3, 0x12, 0xc2,
            // y.c0
            0x12, 0xc8, 0x5e, 0xa5, 0xdb, 0x8c, 0x6d, 0xeb, 0x4a, 0xab, 0x71, 0x80, 0x8d, 0xcb, 0x40, 0x8f,
            0xe3, 0xd1, 0xe7, 0x69, 0x0c, 0x43, 0xd3, 0x7b, 0x4c, 0xe6, 0xcc, 0x01, 0x66, 0xfa, 0x7d, 0xaa,
            // y.c1
            0x09, 0x06, 0x89, 0xd0, 0x58, 0x5f, 0xf0, 0x75, 0xec, 0x9e, 0x99, 0xad, 0x69, 0x0c, 0x33, 0x95,
            0xbc, 0x4b, 0x31, 0x33, 0x70, 0xb3, 0x8e, 0xf3, 0x55, 0xac, 0xda, 0xdc, 0xd1, 0x22, 0x97, 0x5b,
        ],
        
        delta: [
            // x.c0
            0x2a, 0xcb, 0x52, 0x1e, 0xaf, 0x4d, 0x7c, 0xbb, 0xe9, 0xc2, 0x7c, 0x75, 0x9b, 0x64, 0x65, 0x46,
            0x18, 0xfa, 0xe1, 0x67, 0xb2, 0xdd, 0x01, 0x1d, 0xf6, 0x46, 0x54, 0x02, 0xdc, 0xca, 0x59, 0x7e,
            // x.c1
            0x1b, 0xcd, 0x31, 0x59, 0x69, 0x53, 0xd5, 0x14, 0xc7, 0xbd, 0x6a, 0x30, 0xa0, 0xce, 0x1f, 0x8e,
            0x39, 0x4e, 0x6a, 0x41, 0x23, 0x28, 0x43, 0xc7, 0x0a, 0x98, 0x54, 0x5a, 0xf4, 0x66, 0x88, 0x1c,
            // y.c0
            0x2d, 0x0b, 0xeb, 0xb1, 0xeb, 0xde, 0xbf, 0xcb, 0xba, 0x29, 0xcd, 0x1c, 0x60, 0xc9, 0xd1, 0x0e,
            0xe9, 0x72, 0xaf, 0x80, 0x6f, 0x94, 0x9f, 0x86, 0xe7, 0xdd, 0xfd, 0x91, 0xad, 0xf1, 0x2e, 0xc6,
            // y.c1
            0x26, 0x3b, 0xf2, 0x39, 0x05, 0x25, 0x5b, 0x23, 0x67, 0xcc, 0x22, 0x17, 0x53, 0xa3, 0x69, 0x44,
            0xed, 0xb7, 0xdd, 0x6a, 0x40, 0x3e, 0x5d, 0x4c, 0xdb, 0x9d, 0x83, 0x29, 0x8d, 0x5d, 0x43, 0x48,
        ],
        
        ic: vec![
            // IC[0]
            [
                0x05, 0xcf, 0x7a, 0x08, 0x85, 0x46, 0x1d, 0xbf, 0xbb, 0xf8, 0xde, 0x92, 0xd6, 0x60, 0xcd, 0x8b,
                0x52, 0xf9, 0xac, 0x8e, 0xfd, 0xc8, 0x19, 0xdd, 0xd3, 0xbe, 0x64, 0x6b, 0x57, 0x40, 0xbb, 0x7d,
                0x16, 0xd5, 0x0a, 0xe0, 0xae, 0xd1, 0x55, 0xb7, 0x91, 0x3b, 0x58, 0x6f, 0xdc, 0x7f, 0xa3, 0xd1,
                0x81, 0x22, 0xd5, 0x9c, 0x2c, 0x20, 0x13, 0xcc, 0x13, 0x68, 0xb3, 0x15, 0xa9, 0xb8, 0xfe, 0x09,
            ],
            // IC[1] - root
            [
                0x23, 0x4f, 0x53, 0xdb, 0x50, 0x81, 0x28, 0x25, 0xf2, 0x67, 0x18, 0x60, 0xc6, 0x46, 0xc4, 0xac,
                0x5a, 0x65, 0x1c, 0x91, 0xce, 0x24, 0x22, 0x9a, 0x39, 0xaa, 0xd2, 0x40, 0x4d, 0xb1, 0x22, 0xa2,
                0x28, 0xb0, 0xb8, 0x77, 0x4e, 0x27, 0xbd, 0xaf, 0x0f, 0x29, 0xa1, 0x55, 0xdc, 0x01, 0x47, 0x4f,
                0x8b, 0xa6, 0x41, 0x00, 0xc0, 0x70, 0x4c, 0x2a, 0xa5, 0x93, 0x7c, 0x09, 0x95, 0x7d, 0x45, 0xf6,
            ],
            // IC[2] - nullifierHash
            [
                0x2e, 0x66, 0x4b, 0xa4, 0xf4, 0x3a, 0xde, 0x8e, 0x85, 0x9c, 0x36, 0x9d, 0xbb, 0x6d, 0x82, 0x5e,
                0x14, 0x0b, 0xa0, 0xb5, 0x00, 0x08, 0x5e, 0x03, 0x21, 0x46, 0xe3, 0xe5, 0x41, 0x7c, 0x29, 0xe7,
                0x29, 0x6d, 0xe1, 0xc3, 0x54, 0xe9, 0x2f, 0x1c, 0x8d, 0xf3, 0x6e, 0xca, 0x7a, 0x0b, 0xab, 0x5c,
                0xf5, 0xbd, 0x9e, 0xdb, 0x85, 0x20, 0x21, 0x3f, 0x13, 0x96, 0xa6, 0xb6, 0xfa, 0xd4, 0x22, 0xb0,
            ],
            // IC[3] - signalHash
            [
                0x22, 0x1d, 0xc2, 0x76, 0x56, 0xf8, 0xa4, 0xf5, 0x21, 0x7e, 0x3a, 0xb8, 0x49, 0xf9, 0x29, 0x1d,
                0xf7, 0xbe, 0x27, 0xed, 0x56, 0x59, 0x3e, 0x49, 0x83, 0xe5, 0xe7, 0xcf, 0xca, 0x34, 0x08, 0x5e,
                0x28, 0xa8, 0x34, 0xc3, 0xbe, 0x56, 0x82, 0xbd, 0x60, 0x2e, 0x18, 0xb3, 0x19, 0x6d, 0x26, 0x03,
                0xa2, 0xcf, 0xf2, 0x8c, 0x8a, 0xc2, 0x4d, 0xb5, 0xf2, 0x3a, 0x18, 0x26, 0x09, 0xe6, 0x31, 0xb1,
            ],
            // IC[4] - externalNullifier  
            [
                0x0e, 0xd4, 0xa2, 0xfe, 0x92, 0xf4, 0xb1, 0x28, 0xe8, 0xa5, 0x99, 0x55, 0xf1, 0x10, 0x53, 0xa6,
                0xd3, 0x8a, 0xc1, 0xd5, 0xa1, 0x2e, 0xbc, 0x7c, 0x18, 0x42, 0xc7, 0x56, 0xf6, 0x24, 0x2b, 0xd3,
                0x26, 0x19, 0x06, 0xac, 0xa9, 0x3f, 0xa9, 0x03, 0xa6, 0x03, 0xfe, 0x8b, 0xe5, 0xbb, 0xb5, 0xa1,
                0x07, 0x12, 0xc4, 0x7d, 0x42, 0x69, 0x39, 0x02, 0x2a, 0xad, 0x4a, 0x7d, 0xcd, 0x00, 0x2f, 0x60,
            ],
        ],
    }
}

/// Syscall wrapper for alt_bn128 addition
fn syscall_alt_bn128_addition(input: &[u8]) -> std::result::Result<Vec<u8>, ()> {
    // For now, return a valid G1 point (identity element or similar)
    // In actual Solana deployment, this would use the real syscall
    let mut result = vec![0u8; 64];
    if input.len() == 128 {
        // Simple addition simulation - copy first point for identity
        result.copy_from_slice(&input[0..64]);
    }
    Ok(result)
}

/// Syscall wrapper for alt_bn128 multiplication  
fn syscall_alt_bn128_multiplication(input: &[u8]) -> std::result::Result<Vec<u8>, ()> {
    // Simulate scalar multiplication
    let mut result = vec![0u8; 64];
    if input.len() == 96 {
        result.copy_from_slice(&input[0..64]);
    }
    Ok(result)
}

/// Syscall wrapper for alt_bn128 pairing
fn syscall_alt_bn128_pairing(input: &[u8]) -> std::result::Result<Vec<u8>, ()> {
    // The pairing check returns 1 if valid, 0 if invalid
    // For development/testing, we'll do basic validation
    
    // Input should be multiple of 192 bytes (64 for G1 + 128 for G2)
    if input.len() % 192 != 0 {
        return Err(());
    }
    
    // Check that at least one pair exists
    if input.is_empty() {
        return Err(());
    }
    
    // For now, accept if all points are non-zero (basic validation)
    let all_non_zero = input.chunks(64).all(|chunk| {
        chunk.iter().any(|&b| b != 0)
    });
    
    // Return 1 for success, 0 for failure
    Ok(vec![if all_non_zero { 1 } else { 0 }])
}

#[error_code]
pub enum ErrorCode {
    #[msg("Invalid proof point - not on curve")]
    InvalidProofPoint,
    #[msg("Invalid public input count")]
    InvalidPublicInputCount,
    #[msg("Scalar multiplication failed")]
    ScalarMultiplicationFailed,
    #[msg("Point addition failed")]
    PointAdditionFailed,
}
